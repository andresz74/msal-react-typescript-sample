{"ast":null,"code":"/*! @azure/msal-browser v2.28.2 2022-09-06 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\nimport { Constants } from '@azure/msal-common';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// RSA KeyGen Algorithm\n\nvar PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\"; // SHA-256 hashing algorithm\n\nvar S256_HASH_ALG = \"SHA-256\"; // MOD length for PoP tokens\n\nvar MODULUS_LENGTH = 2048; // Public Exponent\n\nvar PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\n\nvar BrowserCrypto =\n/** @class */\nfunction () {\n  function BrowserCrypto(logger) {\n    this.logger = logger;\n\n    if (!this.hasCryptoAPI()) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n    }\n\n    this._keygenAlgorithmOptions = {\n      name: PKCS1_V15_KEYGEN_ALG,\n      hash: S256_HASH_ALG,\n      modulusLength: MODULUS_LENGTH,\n      publicExponent: PUBLIC_EXPONENT\n    };\n  }\n  /**\r\n   * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n   * @param dataString\r\n   */\n\n\n  BrowserCrypto.prototype.sha256Digest = function (dataString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        data = BrowserStringUtils.stringToUtf8Arr(dataString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data)];\n      });\n    });\n  };\n  /**\r\n   * Populates buffer with cryptographically random values.\r\n   * @param dataBuffer\r\n   */\n\n\n  BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    var cryptoObj = window[\"msCrypto\"] || window.crypto;\n\n    if (!cryptoObj.getRandomValues) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n    }\n\n    cryptoObj.getRandomValues(dataBuffer);\n  };\n  /**\r\n   * Generates a keypair based on current keygen algorithm config.\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoGenerateKey(extractable, usages) : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Export key as Json Web Key (JWK)\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.exportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n  /**\r\n   * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserCrypto.getJwkString(key);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoImportKey(keyBuffer, extractable, usages) : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Signs given data with given key\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.sign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoSign(key, data) : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data)];\n      });\n    });\n  };\n  /**\r\n   * Check whether IE crypto or other browser cryptography is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasCryptoAPI = function () {\n    return this.hasIECrypto() || this.hasBrowserCrypto();\n  };\n  /**\r\n   * Checks whether IE crypto (AKA msCrypto) is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasIECrypto = function () {\n    return \"msCrypto\" in window;\n  };\n  /**\r\n   * Check whether browser crypto is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasBrowserCrypto = function () {\n    return \"crypto\" in window;\n  };\n  /**\r\n   * Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getSubtleCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.crypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getMSCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for generating a keypair\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoGenerateKey = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(_this._keygenAlgorithmOptions, extractable, usages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for exportKey\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoExportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, Constants.EMPTY_STRING).replace(/\\n/g, Constants.EMPTY_STRING).replace(/\\t/g, Constants.EMPTY_STRING).split(\" \").join(Constants.EMPTY_STRING).replace(\"\\u0000\", Constants.EMPTY_STRING);\n\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for importKey\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoImportKey = function (keyBuffer, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, _this._keygenAlgorithmOptions, extractable, usages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for sign JWT\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoSign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(_this._keygenAlgorithmOptions, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns stringified jwk.\r\n   * @param jwk\r\n   */\n\n\n  BrowserCrypto.getJwkString = function (jwk) {\n    return JSON.stringify(jwk, Object.keys(jwk).sort());\n  };\n\n  return BrowserCrypto;\n}();\n\nexport { BrowserCrypto };","map":{"version":3,"mappings":"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","names":["PKCS1_V15_KEYGEN_ALG","S256_HASH_ALG","MODULUS_LENGTH","PUBLIC_EXPONENT","Uint8Array","logger","hasCryptoAPI","BrowserAuthError","createCryptoNotAvailableError","_keygenAlgorithmOptions","name","hash","modulusLength","publicExponent","BrowserCrypto","dataString","data","BrowserStringUtils","stringToUtf8Arr","hasIECrypto","getMSCryptoDigest","getSubtleCryptoDigest","dataBuffer","cryptoObj","window","crypto","getRandomValues","extractable","usages","msCryptoGenerateKey","subtle","generateKey","key","msCryptoExportJwk","exportKey","KEY_FORMAT_JWK","keyString","getJwkString","keyBuffer","stringToArrayBuffer","msCryptoImportKey","importKey","msCryptoSign","sign","hasBrowserCrypto","algorithm","digest","Promise","resolve","reject","digestOperation","buffer","addEventListener","e","target","result","error","msGenerateKey","_this","msExportKey","resultBuffer","resultString","utf8ArrToString","replace","Constants","EMPTY_STRING","split","join","JSON","parse","msImportKey","msSign","jwk","stringify","Object","keys","sort"],"sources":["../../src/crypto/BrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\nimport { Logger } from \"..\";\nimport { Constants } from \"@azure/msal-common\";\n/**\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\n */\n// RSA KeyGen Algorithm\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\n// SHA-256 hashing algorithm\nconst S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nconst MODULUS_LENGTH = 2048;\n// Public Exponent\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\n\n/**\n * This class implements functions used by the browser library to perform cryptography operations such as\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\n */\nexport class BrowserCrypto {\n\n    private _keygenAlgorithmOptions: RsaHashedKeyGenParams;\n    private logger: Logger;\n\n    constructor(logger: Logger) {\n        this.logger = logger;\n        \n        if (!(this.hasCryptoAPI())) {\n            throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n        }\n\n        this._keygenAlgorithmOptions = {\n            name: PKCS1_V15_KEYGEN_ALG,\n            hash: S256_HASH_ALG,\n            modulusLength: MODULUS_LENGTH,\n            publicExponent: PUBLIC_EXPONENT\n        };\n    }\n\n    /**\n     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\n     * @param dataString \n     */\n    async sha256Digest(dataString: string): Promise<ArrayBuffer> {\n        const data = BrowserStringUtils.stringToUtf8Arr(dataString);\n\n        return this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data);\n    }\n\n    /**\n     * Populates buffer with cryptographically random values.\n     * @param dataBuffer \n     */\n    getRandomValues(dataBuffer: Uint8Array): void {\n        const cryptoObj = window[\"msCrypto\"] || window.crypto;\n        if (!cryptoObj.getRandomValues) {\n            throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n        }\n        cryptoObj.getRandomValues(dataBuffer);\n    }\n\n    /**\n     * Generates a keypair based on current keygen algorithm config.\n     * @param extractable \n     * @param usages \n     */\n    async generateKeyPair(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\n        return (\n            this.hasIECrypto() ? \n                this.msCryptoGenerateKey(extractable, usages) \n                : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)\n        ) as Promise<CryptoKeyPair>;\n    }\n\n    /**\n     * Export key as Json Web Key (JWK)\n     * @param key \n     * @param format \n     */\n    async exportJwk(key: CryptoKey): Promise<JsonWebKey> {\n        return this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);\n    }\n\n    /**\n     * Imports key as Json Web Key (JWK), can set extractable and usages.\n     * @param key \n     * @param format \n     * @param extractable \n     * @param usages \n     */\n    async importJwk(key: JsonWebKey, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\n        const keyString = BrowserCrypto.getJwkString(key);\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n\n        return this.hasIECrypto() ? \n            this.msCryptoImportKey(keyBuffer, extractable, usages) \n            : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages);\n    }\n\n    /**\n     * Signs given data with given key\n     * @param key \n     * @param data \n     */\n    async sign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return this.hasIECrypto() ?\n            this.msCryptoSign(key, data)\n            : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data);\n    }\n\n    /**\n     * Check whether IE crypto or other browser cryptography is available.\n     */\n    private hasCryptoAPI(): boolean {\n        return this.hasIECrypto() || this.hasBrowserCrypto();\n    }\n\n    /**\n     * Checks whether IE crypto (AKA msCrypto) is available.\n     */\n    private hasIECrypto(): boolean {\n        return \"msCrypto\" in window;\n    }\n\n    /**\n     * Check whether browser crypto is available.\n     */\n    private hasBrowserCrypto(): boolean {\n        return \"crypto\" in window;\n    }\n\n    /**\n     * Helper function for SHA digest.\n     * @param algorithm \n     * @param data \n     */\n    private async getSubtleCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\n        return window.crypto.subtle.digest(algorithm, data);\n    }\n\n    /**\n     * IE Helper function for SHA digest.\n     * @param algorithm \n     * @param data \n     */\n    private async getMSCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n            digestOperation.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for generating a keypair\n     * @param extractable \n     * @param usages \n     */\n    private async msCryptoGenerateKey(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages);\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for exportKey\n     * @param key \n     * @param format \n     */\n    private async msCryptoExportJwk(key: CryptoKey): Promise<JsonWebKey> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\n                const resultBuffer: ArrayBuffer = e.target.result;\n\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\n                    .replace(/\\r/g, Constants.EMPTY_STRING)\n                    .replace(/\\n/g, Constants.EMPTY_STRING)\n                    .replace(/\\t/g, Constants.EMPTY_STRING)\n                    .split(\" \").join(Constants.EMPTY_STRING)\n                    .replace(\"\\u0000\", Constants.EMPTY_STRING);\n\n                try {\n                    resolve(JSON.parse(resultString));\n                } catch (e) {\n                    reject(e);\n                }\n            });\n\n            msExportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for importKey\n     * @param key \n     * @param format \n     * @param extractable \n     * @param usages \n     */\n    private async msCryptoImportKey(keyBuffer: ArrayBuffer, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, this._keygenAlgorithmOptions, extractable, usages);\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msImportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for sign JWT\n     * @param key \n     * @param data \n     */\n    private async msCryptoSign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msSign = window[\"msCrypto\"].subtle.sign(this._keygenAlgorithmOptions, key, data);\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msSign.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Returns stringified jwk.\n     * @param jwk \n     */\n    static getJwkString(jwk: JsonWebKey): string {\n        return JSON.stringify(jwk, Object.keys(jwk).sort());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}