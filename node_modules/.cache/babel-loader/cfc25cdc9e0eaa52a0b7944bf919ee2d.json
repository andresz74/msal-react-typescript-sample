{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { PerformanceEventStatus } from './PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PerformanceClient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.measurementsById = new Map();\n  }\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n\n\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n\n    var _a, _b; // Generate a placeholder correlation if the request does not provide one\n\n\n    var eventCorrelationId = correlationId || this.generateId();\n\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    }\n\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId\n    }; // Store in progress events so they can be discarded if not ended properly\n\n    this.cacheEventByCorrelationId(inProgressEvent);\n    this.cacheMeasurement(inProgressEvent, performanceMeasurement); // Return the event and functions the caller can use to properly end/flush the measurement\n\n    return {\n      endMeasurement: function (event) {\n        var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\n\n        if (completedEvent) {\n          // Cache event so that submeasurements can be added downstream\n          _this.cacheEventByCorrelationId(completedEvent);\n        }\n\n        return completedEvent;\n      },\n      flushMeasurement: function () {\n        return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n\n\n  PerformanceClient.prototype.endMeasurement = function (event) {\n    var performanceMeasurement = this.measurementsById.get(event.eventId);\n\n    if (performanceMeasurement) {\n      // Immediately delete so that the same event isnt ended twice\n      this.measurementsById.delete(event.eventId);\n      performanceMeasurement.endMeasurement();\n      var durationMs = performanceMeasurement.flushMeasurement(); // null indicates no measurement was taken (e.g. needed performance APIs not present)\n\n      if (durationMs !== null) {\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\n\n        var completedEvent = __assign(__assign({\n          // Allow duration to be overwritten when event ends (e.g. testing), but not status\n          durationMs: Math.round(durationMs)\n        }, event), {\n          status: PerformanceEventStatus.Completed\n        });\n\n        return completedEvent;\n      } else {\n        this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n    }\n\n    return null;\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n\n\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (existingEvents) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      existingEvents.set(event.eventId, event);\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n    }\n  };\n  /**\r\n   * Cache measurements by their id.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   */\n\n\n  PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\n    this.measurementsById.set(event.eventId, measurement);\n  };\n  /**\r\n   * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\n    var _this = this;\n\n    this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\n    var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n\n    if (eventsForCorrelationId) {\n      this.discardMeasurements(correlationId);\n      /*\r\n       * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n       * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n       * IE only supports Map.forEach.\r\n       */\n\n      var completedEvents_1 = [];\n      eventsForCorrelationId.forEach(function (event) {\n        if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n          _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\n\n          var completedEvent = _this.endMeasurement(event);\n\n          if (completedEvent) {\n            completedEvents_1.push(completedEvent);\n          }\n        }\n\n        completedEvents_1.push(event);\n      }); // Sort events by start time (earliest first)\n\n      var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) {\n        return eventA.startTimeMs - eventB.startTimeMs;\n      }); // Take completed top level event and add completed submeasurements durations as properties\n\n      var topLevelEvents = sortedCompletedEvents.filter(function (event) {\n        return event.name === measureName && event.status === PerformanceEventStatus.Completed;\n      });\n\n      if (topLevelEvents.length > 0) {\n        /*\r\n         * Only take the first top-level event if there are multiple events with the same correlation id.\r\n         * This greatly simplifies logic for submeasurements.\r\n         */\n        if (topLevelEvents.length > 1) {\n          this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n        }\n\n        var topLevelEvent = topLevelEvents[0];\n        this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId); // Build event object with top level and sub measurements\n\n        var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\n          if (current.name !== measureName) {\n            _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId); // TODO: Emit additional properties for each subMeasurement\n\n\n            var subMeasurementName = current.name + \"DurationMs\";\n            /*\r\n             * Some code paths, such as resolving an authority, can occur multiple times.\r\n             * Only take the first measurement, since the second could be read from the cache,\r\n             * or due to the same correlation id being used for two distinct requests.\r\n             */\n\n            if (!previous[subMeasurementName]) {\n              previous[subMeasurementName] = current.durationMs;\n            } else {\n              _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\n            }\n\n            if (current.accessTokenSize) {\n              previous.accessTokenSize = current.accessTokenSize;\n            }\n\n            if (current.idTokenSize) {\n              previous.idTokenSize = current.idTokenSize;\n            }\n          }\n\n          return previous;\n        }, topLevelEvent);\n        this.emitEvents([eventToEmit], eventToEmit.correlationId);\n      } else {\n        this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\n      }\n    } else {\n      this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n    }\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n\n\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n\n      callback.apply(null, [events]);\n    });\n  };\n\n  return PerformanceClient;\n}();\n\nexport { PerformanceClient };","map":{"version":3,"mappings":"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","names":["PerformanceClient","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","callbacks","Map","eventsByCorrelationId","measurementsById","measureName","correlationId","_this","eventCorrelationId","generateId","info","trace","performanceMeasurement","startPerformanceMeasuremeant","startMeasurement","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","appName","_a","appVersion","_b","name","startTimeMs","Date","now","cacheEventByCorrelationId","cacheMeasurement","endMeasurement","event","completedEvent","__assign","flushMeasurement","flushMeasurements","discardMeasurement","discardMeasurements","measurement","get","delete","durationMs","Math","round","Completed","existingEvents","set","eventsForCorrelationId","completedEvents_1","forEach","push","sortedCompletedEvents","sort","eventA","eventB","topLevelEvents","filter","length","verbose","topLevelEvent","eventToEmit","reduce","previous","current","subMeasurementName","accessTokenSize","idTokenSize","emitEvents","addPerformanceCallback","callback","callbackId","removePerformanceCallback","result","events","apply"],"sources":["../../../src/telemetry/performance/PerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\nimport { Logger } from \"../../logger/Logger\";\nimport { InProgressPerformanceEvent, IPerformanceClient, PerformanceCallbackFunction } from \"./IPerformanceClient\";\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\nimport { PerformanceEvent, PerformanceEvents, PerformanceEventStatus } from \"./PerformanceEvent\";\n\nexport abstract class PerformanceClient implements IPerformanceClient {\n    protected authority: string;\n    protected libraryName: string;\n    protected libraryVersion: string;\n    protected applicationTelemetry: ApplicationTelemetry;\n    protected clientId: string;\n    protected logger: Logger;\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\n\n    /**\n     * Multiple events with the same correlation id.\n     * Double keyed by correlation id and event id.\n     * @protected\n     * @type {Map<string, Map<string, PerformanceEvent>>}\n     */\n    protected eventsByCorrelationId: Map<string, Map<string, PerformanceEvent>>;\n\n    /**\n     * Underlying performance measurements for each operation\n     *\n     * @protected\n     * @type {Map<string, IPerformanceMeasurement>}\n     */\n    protected measurementsById: Map<string, IPerformanceMeasurement>;\n\n    /**\n     * Creates an instance of PerformanceClient, \n     * an abstract class containing core performance telemetry logic.\n     *\n     * @constructor\n     * @param {string} clientId Client ID of the application\n     * @param {string} authority Authority used by the application\n     * @param {Logger} logger Logger used by the application\n     * @param {string} libraryName Name of the library\n     * @param {string} libraryVersion Version of the library\n     */\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\n        this.authority = authority;\n        this.libraryName = libraryName;\n        this.libraryVersion = libraryVersion;\n        this.applicationTelemetry = applicationTelemetry;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.callbacks = new Map();\n        this.eventsByCorrelationId = new Map();\n        this.measurementsById = new Map();\n    }\n\n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     *\n     * @abstract\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    abstract startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement;\n\n    /**\n     * Generates and returns a unique id, typically a guid.\n     *\n     * @abstract\n     * @returns {string}\n     */\n    abstract generateId(): string;\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {InProgressPerformanceEvent}\n     */\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\n        // Generate a placeholder correlation if the request does not provide one\n        const eventCorrelationId = correlationId || this.generateId();\n        if (!correlationId) {\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n        }\n\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n        const performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n        performanceMeasurement.startMeasurement();\n\n        const inProgressEvent: PerformanceEvent = {\n            eventId: this.generateId(),\n            status: PerformanceEventStatus.InProgress,\n            authority: this.authority,\n            libraryName: this.libraryName,\n            libraryVersion: this.libraryVersion,\n            appName: this.applicationTelemetry?.appName,\n            appVersion: this.applicationTelemetry?.appVersion,\n            clientId: this.clientId,\n            name: measureName,\n            startTimeMs: Date.now(),\n            correlationId: eventCorrelationId,\n        };\n\n        // Store in progress events so they can be discarded if not ended properly\n        this.cacheEventByCorrelationId(inProgressEvent);\n        this.cacheMeasurement(inProgressEvent, performanceMeasurement);\n\n        // Return the event and functions the caller can use to properly end/flush the measurement\n        return {\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\n                const completedEvent = this.endMeasurement({\n                    // Initial set of event properties\n                    ...inProgressEvent,\n                    // Properties set when event ends\n                    ...event\n                });\n\n                if (completedEvent) {\n                    // Cache event so that submeasurements can be added downstream\n                    this.cacheEventByCorrelationId(completedEvent);\n                }\n\n                return completedEvent;\n            },\n            flushMeasurement: () => {\n                return this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n            },\n            discardMeasurement: () => {\n                return this.discardMeasurements(inProgressEvent.correlationId);\n            },\n            measurement: performanceMeasurement,\n            event: inProgressEvent\n        };\n\n    }\n\n    /**\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n     * as consumers should instead use the function returned by startMeasurement.\n     *\n     * @param {PerformanceEvent} event\n     * @returns {(PerformanceEvent | null)}\n     */\n    endMeasurement(event: PerformanceEvent): PerformanceEvent | null {\n        const performanceMeasurement = this.measurementsById.get(event.eventId);\n        if (performanceMeasurement) {\n            // Immediately delete so that the same event isnt ended twice\n            this.measurementsById.delete(event.eventId);\n            performanceMeasurement.endMeasurement();\n            const durationMs = performanceMeasurement.flushMeasurement();\n            // null indicates no measurement was taken (e.g. needed performance APIs not present)\n            if (durationMs !== null) {\n                this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n\n                const completedEvent: PerformanceEvent = {\n                    // Allow duration to be overwritten when event ends (e.g. testing), but not status\n                    durationMs: Math.round(durationMs),\n                    ...event,\n                    status: PerformanceEventStatus.Completed,\n                };\n\n                return completedEvent;\n            } else {\n                this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n            }\n        } else {\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n        }\n\n        return null;\n    }\n\n    /**\n     * Upserts event into event cache.\n     * First key is the correlation id, second key is the event id.\n     * Allows for events to be grouped by correlation id,\n     * and to easily allow for properties on them to be updated.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     */\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\n        const existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n        if (existingEvents) {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n            existingEvents.set(event.eventId, event);\n        } else {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n        }\n    }\n\n    /**\n     * Cache measurements by their id.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     * @param {IPerformanceMeasurement} measurement\n     */\n    private cacheMeasurement(event: PerformanceEvent, measurement: IPerformanceMeasurement) {\n        this.measurementsById.set(event.eventId, measurement);\n    }\n\n    /**\n     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {string} correlationId\n     */\n    flushMeasurements(measureName: PerformanceEvents, correlationId: string): void {\n        this.logger.trace(`PerformanceClient: Performance measurements flushed for ${measureName}`, correlationId);\n        const eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n        if (eventsForCorrelationId) {\n            this.discardMeasurements(correlationId);\n\n            /*\n             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\n             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\n             * IE only supports Map.forEach.\n             */\n            const completedEvents: PerformanceEvent[] = [];\n            eventsForCorrelationId.forEach(event => {\n                if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n                    this.logger.trace(`PerformanceClient: Incomplete submeasurement ${event.name} found for ${measureName}`, correlationId);\n\n                    const completedEvent = this.endMeasurement(event);\n                    if (completedEvent) {\n                        completedEvents.push(completedEvent);\n                    }\n                }\n\n                completedEvents.push(event);\n            });\n\n            // Sort events by start time (earliest first)\n            const sortedCompletedEvents = completedEvents.sort((eventA, eventB) => eventA.startTimeMs - eventB.startTimeMs);\n\n            // Take completed top level event and add completed submeasurements durations as properties\n            const topLevelEvents = sortedCompletedEvents.filter(event => event.name === measureName && event.status === PerformanceEventStatus.Completed);\n            if (topLevelEvents.length > 0) {\n                /*\n                 * Only take the first top-level event if there are multiple events with the same correlation id.\n                 * This greatly simplifies logic for submeasurements.\n                 */\n                if (topLevelEvents.length > 1) {\n                    this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n                }\n                const topLevelEvent = topLevelEvents[0];\n\n                this.logger.verbose(`PerformanceClient: Measurement found for ${measureName}`, correlationId);\n\n                // Build event object with top level and sub measurements\n                const eventToEmit = sortedCompletedEvents.reduce((previous, current) => {\n                    if (current.name !== measureName) {\n                        this.logger.trace(`PerformanceClient: Complete submeasurement found for ${current.name}`, correlationId);\n                        // TODO: Emit additional properties for each subMeasurement\n                        const subMeasurementName = `${current.name}DurationMs`;\n                        /*\n                         * Some code paths, such as resolving an authority, can occur multiple times.\n                         * Only take the first measurement, since the second could be read from the cache,\n                         * or due to the same correlation id being used for two distinct requests.\n                         */\n                        if (!previous[subMeasurementName]) {\n                            previous[subMeasurementName] = current.durationMs;\n                        } else {\n                            this.logger.verbose(`PerformanceClient: Submeasurement for ${measureName} already exists for ${current.name}, ignoring`, correlationId);\n                        }\n                        if (current.accessTokenSize) {\n                            previous.accessTokenSize = current.accessTokenSize;\n                        }\n                        if (current.idTokenSize) {\n                            previous.idTokenSize = current.idTokenSize;\n                        }\n                    }\n\n                    return previous;\n                }, topLevelEvent);\n\n                this.emitEvents([eventToEmit], eventToEmit.correlationId);\n            } else {\n                this.logger.verbose(`PerformanceClient: No completed top-level measurements found for ${measureName}`, correlationId);\n            }\n        } else {\n            this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n        }\n    }\n\n    /**\n     * Removes measurements for a given correlation id.\n     *\n     * @param {string} correlationId\n     */\n    discardMeasurements(correlationId: string): void {\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n        this.eventsByCorrelationId.delete(correlationId);\n    }\n\n    /**\n     * Registers a callback function to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        const callbackId = this.generateId();\n        this.callbacks.set(callbackId, callback);\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n\n        return callbackId;\n    }\n\n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        const result = this.callbacks.delete(callbackId);\n\n        if (result) {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n        } else {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n        }\n\n        return result;\n    }\n\n    /**\n     * Emits events to all registered callbacks.\n     *\n     * @param {PerformanceEvent[]} events\n     * @param {?string} [correlationId]\n     */\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n            callback.apply(null, [events]);\n        });\n    }\n\n}\n"]},"metadata":{},"sourceType":"module"}