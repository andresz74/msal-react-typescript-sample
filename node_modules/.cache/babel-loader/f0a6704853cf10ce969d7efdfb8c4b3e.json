{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { StringUtils } from './StringUtils.js';\nimport { Constants } from './Constants.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class which provides helpers for OAuth 2.0 protocol specific values\r\n */\n\nvar ProtocolUtils =\n/** @class */\nfunction () {\n  function ProtocolUtils() {}\n  /**\r\n   * Appends user state with random guid, or returns random guid.\r\n   * @param userState\r\n   * @param randomGuid\r\n   */\n\n\n  ProtocolUtils.setRequestState = function (cryptoObj, userState, meta) {\n    var libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\n    return !StringUtils.isEmpty(userState) ? \"\" + libraryState + Constants.RESOURCE_DELIM + userState : libraryState;\n  };\n  /**\r\n   * Generates the state value used by the common library.\r\n   * @param randomGuid\r\n   * @param cryptoObj\r\n   */\n\n\n  ProtocolUtils.generateLibraryState = function (cryptoObj, meta) {\n    if (!cryptoObj) {\n      throw ClientAuthError.createNoCryptoObjectError(\"generateLibraryState\");\n    } // Create a state object containing a unique id and the timestamp of the request creation\n\n\n    var stateObj = {\n      id: cryptoObj.createNewGuid()\n    };\n\n    if (meta) {\n      stateObj.meta = meta;\n    }\n\n    var stateString = JSON.stringify(stateObj);\n    return cryptoObj.base64Encode(stateString);\n  };\n  /**\r\n   * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\r\n   * @param state\r\n   * @param cryptoObj\r\n   */\n\n\n  ProtocolUtils.parseRequestState = function (cryptoObj, state) {\n    if (!cryptoObj) {\n      throw ClientAuthError.createNoCryptoObjectError(\"parseRequestState\");\n    }\n\n    if (StringUtils.isEmpty(state)) {\n      throw ClientAuthError.createInvalidStateError(state, \"Null, undefined or empty state\");\n    }\n\n    try {\n      // Split the state between library state and user passed state and decode them separately\n      var splitState = state.split(Constants.RESOURCE_DELIM);\n      var libraryState = splitState[0];\n      var userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;\n      var libraryStateString = cryptoObj.base64Decode(libraryState);\n      var libraryStateObj = JSON.parse(libraryStateString);\n      return {\n        userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,\n        libraryState: libraryStateObj\n      };\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(state, e);\n    }\n  };\n\n  return ProtocolUtils;\n}();\n\nexport { ProtocolUtils };","map":{"version":3,"mappings":";;;;;;AAAA;;;AAGG;;AA2BH;;AAEG;;AACH;AAAA;AAAA;EAAA,0BAiEC;EA/DG;;;;AAIG;;;EACIA,gCAAP,UAAuBC,SAAvB,EAA2CC,SAA3C,EAA+DC,IAA/D,EAA4F;IACxF,IAAMC,YAAY,GAAGJ,aAAa,CAACK,oBAAd,CAAmCJ,SAAnC,EAA8CE,IAA9C,CAArB;IACA,OAAO,CAACG,WAAW,CAACC,OAAZ,CAAoBL,SAApB,CAAD,GAAkC,KAAGE,YAAH,GAAkBI,SAAS,CAACC,cAA5B,GAA6CP,SAA/E,GAA6FE,YAApG;EACH,CAHM;EAKP;;;;AAIG;;;EACIJ,qCAAP,UAA4BC,SAA5B,EAAgDE,IAAhD,EAA6E;IACzE,IAAI,CAACF,SAAL,EAAgB;MACZ,MAAMS,eAAe,CAACC,yBAAhB,CAA0C,sBAA1C,CAAN;IACH,CAHwE;;;IAMzE,IAAMC,QAAQ,GAAuB;MACjCC,EAAE,EAAEZ,SAAS,CAACa,aAAV;IAD6B,CAArC;;IAIA,IAAIX,IAAJ,EAAU;MACNS,QAAQ,CAACT,IAAT,GAAgBA,IAAhB;IACH;;IAED,IAAMY,WAAW,GAAGC,IAAI,CAACC,SAAL,CAAeL,QAAf,CAApB;IAEA,OAAOX,SAAS,CAACiB,YAAV,CAAuBH,WAAvB,CAAP;EACH,CAjBM;EAmBP;;;;AAIG;;;EACIf,kCAAP,UAAyBC,SAAzB,EAA6CkB,KAA7C,EAA0D;IACtD,IAAI,CAAClB,SAAL,EAAgB;MACZ,MAAMS,eAAe,CAACC,yBAAhB,CAA0C,mBAA1C,CAAN;IACH;;IAED,IAAIL,WAAW,CAACC,OAAZ,CAAoBY,KAApB,CAAJ,EAAgC;MAC5B,MAAMT,eAAe,CAACU,uBAAhB,CAAwCD,KAAxC,EAA+C,gCAA/C,CAAN;IACH;;IAED,IAAI;;MAEA,IAAME,UAAU,GAAGF,KAAK,CAACG,KAAN,CAAYd,SAAS,CAACC,cAAtB,CAAnB;MACA,IAAML,YAAY,GAAGiB,UAAU,CAAC,CAAD,CAA/B;MACA,IAAMnB,SAAS,GAAGmB,UAAU,CAACE,MAAX,GAAoB,CAApB,GAAwBF,UAAU,CAACG,KAAX,CAAiB,CAAjB,EAAoBC,IAApB,CAAyBjB,SAAS,CAACC,cAAnC,CAAxB,GAA6ED,SAAS,CAACkB,YAAzG;MACA,IAAMC,kBAAkB,GAAG1B,SAAS,CAAC2B,YAAV,CAAuBxB,YAAvB,CAA3B;MACA,IAAMyB,eAAe,GAAGb,IAAI,CAACc,KAAL,CAAWH,kBAAX,CAAxB;MACA,OAAO;QACHI,gBAAgB,EAAE,CAACzB,WAAW,CAACC,OAAZ,CAAoBL,SAApB,CAAD,GAAkCA,SAAlC,GAA8CM,SAAS,CAACkB,YADvE;QAEHtB,YAAY,EAAEyB;MAFX,CAAP;IAIH,CAXD,CAWE,OAAMG,CAAN,EAAS;MACP,MAAMtB,eAAe,CAACU,uBAAhB,CAAwCD,KAAxC,EAA+Ca,CAA/C,CAAN;IACH;EACJ,CAvBM;;EAwBX,OAAChC,aAAD;AAAC,CAjED","names":["ProtocolUtils","cryptoObj","userState","meta","libraryState","generateLibraryState","StringUtils","isEmpty","Constants","RESOURCE_DELIM","ClientAuthError","createNoCryptoObjectError","stateObj","id","createNewGuid","stateString","JSON","stringify","base64Encode","state","createInvalidStateError","splitState","split","length","slice","join","EMPTY_STRING","libraryStateString","base64Decode","libraryStateObj","parse","userRequestState","e"],"sources":["../../src/utils/ProtocolUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StringUtils } from \"./StringUtils\";\nimport { Constants } from \"./Constants\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n\n/**\n * Type which defines the object that is stringified, encoded and sent in the state value.\n * Contains the following:\n * - id - unique identifier for this request\n * - ts - timestamp for the time the request was made. Used to ensure that token expiration is not calculated incorrectly.\n * - platformState - string value sent from the platform.\n */\nexport type LibraryStateObject = {\n    id: string,\n    meta?: Record<string, string>\n};\n\n/**\n * Type which defines the stringified and encoded object sent to the service in the authorize request.\n */\nexport type RequestStateObject = {\n    userRequestState: string,\n    libraryState: LibraryStateObject\n};\n\n/**\n * Class which provides helpers for OAuth 2.0 protocol specific values\n */\nexport class ProtocolUtils {\n\n    /**\n     * Appends user state with random guid, or returns random guid.\n     * @param userState \n     * @param randomGuid \n     */\n    static setRequestState(cryptoObj: ICrypto, userState?: string, meta?: Record<string, string>): string {\n        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\n        return !StringUtils.isEmpty(userState) ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;\n    }\n\n    /**\n     * Generates the state value used by the common library.\n     * @param randomGuid \n     * @param cryptoObj \n     */\n    static generateLibraryState(cryptoObj: ICrypto, meta?: Record<string, string>): string {\n        if (!cryptoObj) {\n            throw ClientAuthError.createNoCryptoObjectError(\"generateLibraryState\");\n        }\n\n        // Create a state object containing a unique id and the timestamp of the request creation\n        const stateObj: LibraryStateObject = {\n            id: cryptoObj.createNewGuid()\n        };\n\n        if (meta) {\n            stateObj.meta = meta;\n        }\n\n        const stateString = JSON.stringify(stateObj);\n\n        return cryptoObj.base64Encode(stateString);\n    }\n\n    /**\n     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\n     * @param state \n     * @param cryptoObj \n     */\n    static parseRequestState(cryptoObj: ICrypto, state: string): RequestStateObject {\n        if (!cryptoObj) {\n            throw ClientAuthError.createNoCryptoObjectError(\"parseRequestState\");\n        }\n\n        if (StringUtils.isEmpty(state)) {\n            throw ClientAuthError.createInvalidStateError(state, \"Null, undefined or empty state\");\n        }\n\n        try {\n            // Split the state between library state and user passed state and decode them separately\n            const splitState = state.split(Constants.RESOURCE_DELIM);\n            const libraryState = splitState[0];\n            const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;\n            const libraryStateString = cryptoObj.base64Decode(libraryState);\n            const libraryStateObj = JSON.parse(libraryStateString) as LibraryStateObject;\n            return {\n                userRequestState: !StringUtils.isEmpty(userState) ? userState : Constants.EMPTY_STRING,\n                libraryState: libraryStateObj\n            };\n        } catch(e) {\n            throw ClientAuthError.createInvalidStateError(state, e);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}