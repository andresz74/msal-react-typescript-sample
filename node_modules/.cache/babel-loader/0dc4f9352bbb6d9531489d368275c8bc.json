{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { CredentialType, CacheType, Constants, Separators, AuthenticationScheme } from '../../utils/Constants.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\r\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\r\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\r\n * }\r\n */\n\nvar CredentialEntity =\n/** @class */\nfunction () {\n  function CredentialEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  CredentialEntity.prototype.generateAccountId = function () {\n    return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n  };\n  /**\r\n   * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\r\n   */\n\n\n  CredentialEntity.prototype.generateCredentialId = function () {\n    return CredentialEntity.generateCredentialIdForCacheKey(this.credentialType, this.clientId, this.realm, this.familyId);\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n\n\n  CredentialEntity.prototype.generateTarget = function () {\n    return CredentialEntity.generateTargetForCacheKey(this.target);\n  };\n  /**\r\n   * generates credential key\r\n   */\n\n\n  CredentialEntity.prototype.generateCredentialKey = function () {\n    return CredentialEntity.generateCredentialCacheKey(this.homeAccountId, this.environment, this.credentialType, this.clientId, this.realm, this.target, this.familyId, this.tokenType, this.requestedClaimsHash);\n  };\n  /**\r\n   * returns the type of the cache (in this case credential)\r\n   */\n\n\n  CredentialEntity.prototype.generateType = function () {\n    switch (this.credentialType) {\n      case CredentialType.ID_TOKEN:\n        return CacheType.ID_TOKEN;\n\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        return CacheType.ACCESS_TOKEN;\n\n      case CredentialType.REFRESH_TOKEN:\n        return CacheType.REFRESH_TOKEN;\n\n      default:\n        {\n          throw ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n    }\n  };\n  /**\r\n   * helper function to return `CredentialType`\r\n   * @param key\r\n   */\n\n\n  CredentialEntity.getCredentialType = function (key) {\n    // First keyword search will match all \"AccessToken\" and \"AccessToken_With_AuthScheme\" credentials\n    if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {\n      // Perform second search to differentiate between \"AccessToken\" and \"AccessToken_With_AuthScheme\" credential types\n      if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {\n        return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n      }\n\n      return CredentialType.ACCESS_TOKEN;\n    } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {\n      return CredentialType.ID_TOKEN;\n    } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {\n      return CredentialType.REFRESH_TOKEN;\n    }\n\n    return Constants.NOT_DEFINED;\n  };\n  /**\r\n   * generates credential key\r\n   * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\r\n   */\n\n\n  CredentialEntity.generateCredentialCacheKey = function (homeAccountId, environment, credentialType, clientId, realm, target, familyId, tokenType, requestedClaimsHash) {\n    var credentialKey = [this.generateAccountIdForCacheKey(homeAccountId, environment), this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId), this.generateTargetForCacheKey(target), this.generateClaimsHashForCacheKey(requestedClaimsHash), this.generateSchemeForCacheKey(tokenType)];\n    return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * generates Account Id for keys\r\n   * @param homeAccountId\r\n   * @param environment\r\n   */\n\n\n  CredentialEntity.generateAccountIdForCacheKey = function (homeAccountId, environment) {\n    var accountId = [homeAccountId, environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generates Credential Id for keys\r\n   * @param credentialType\r\n   * @param realm\r\n   * @param clientId\r\n   * @param familyId\r\n   */\n\n\n  CredentialEntity.generateCredentialIdForCacheKey = function (credentialType, clientId, realm, familyId) {\n    var clientOrFamilyId = credentialType === CredentialType.REFRESH_TOKEN ? familyId || clientId : clientId;\n    var credentialId = [credentialType, clientOrFamilyId, realm || Constants.EMPTY_STRING];\n    return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate target key component as per schema: <target>\r\n   */\n\n\n  CredentialEntity.generateTargetForCacheKey = function (scopes) {\n    return (scopes || Constants.EMPTY_STRING).toLowerCase();\n  };\n  /**\r\n   * Generate requested claims key component as per schema: <requestedClaims>\r\n   */\n\n\n  CredentialEntity.generateClaimsHashForCacheKey = function (requestedClaimsHash) {\n    return (requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n  };\n  /**\r\n   * Generate scheme key componenet as per schema: <scheme>\r\n   */\n\n\n  CredentialEntity.generateSchemeForCacheKey = function (tokenType) {\n    /*\r\n     * PoP Tokens and SSH certs include scheme in cache key\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    return tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? tokenType.toLowerCase() : Constants.EMPTY_STRING;\n  };\n\n  return CredentialEntity;\n}();\n\nexport { CredentialEntity };","map":{"version":3,"mappings":"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","names":["CredentialEntity","generateAccountIdForCacheKey","homeAccountId","environment","generateCredentialIdForCacheKey","credentialType","clientId","realm","familyId","generateTargetForCacheKey","target","generateCredentialCacheKey","tokenType","requestedClaimsHash","CredentialType","ID_TOKEN","CacheType","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","ClientAuthError","createUnexpectedCredentialTypeError","key","indexOf","toLowerCase","Constants","NOT_DEFINED","credentialKey","generateClaimsHashForCacheKey","generateSchemeForCacheKey","join","Separators","CACHE_KEY_SEPARATOR","accountId","clientOrFamilyId","credentialId","EMPTY_STRING","scopes","AuthenticationScheme","BEARER"],"sources":["../../../src/cache/entities/CredentialEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Separators, CredentialType, CacheType, Constants, AuthenticationScheme } from \"../../utils/Constants\";\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\n\n/**\n * Base type for credentials to be stored in the cache: eg: ACCESS_TOKEN, ID_TOKEN etc\n *\n * Key:Value Schema:\n *\n * Key: <home_account_id*>-<environment>-<credential_type>-<client_id>-<realm*>-<target*>-<requestedClaims*>-<scheme*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      tokenType: Matches the authentication scheme for which the token was issued (i.e. Bearer or pop)\n *      requestedClaimsHash: Matches the SHA 256 hash of the claims object included in the token request\n *      userAssertionHash: Matches the SHA 256 hash of the obo_assertion for the OBO flow\n * }\n */\nexport class CredentialEntity {\n    homeAccountId: string;\n    environment: string;\n    credentialType: CredentialType;\n    clientId: string;\n    secret: string;\n    familyId?: string;\n    realm?: string;\n    target?: string;\n    userAssertionHash?: string;\n    tokenType?: AuthenticationScheme;\n    keyId?: string;\n    requestedClaimsHash?: string;\n\n    /**\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n     */\n    generateAccountId(): string {\n        return CredentialEntity.generateAccountIdForCacheKey(this.homeAccountId, this.environment);\n    }\n\n    /**\n     * Generate Credential Id key component as per the schema: <credential_type>-<client_id>-<realm>\n     */\n    generateCredentialId(): string {\n        return CredentialEntity.generateCredentialIdForCacheKey(\n            this.credentialType,\n            this.clientId,\n            this.realm,\n            this.familyId\n        );\n    }\n\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    generateTarget(): string {\n        return CredentialEntity.generateTargetForCacheKey(this.target);\n    }\n\n    /**\n     * generates credential key\n     */\n    generateCredentialKey(): string {\n        return CredentialEntity.generateCredentialCacheKey(\n            this.homeAccountId,\n            this.environment,\n            this.credentialType,\n            this.clientId,\n            this.realm,\n            this.target,\n            this.familyId,\n            this.tokenType,\n            this.requestedClaimsHash,\n        );\n    }\n\n    /**\n     * returns the type of the cache (in this case credential)\n     */\n    generateType(): number {\n        switch (this.credentialType) {\n            case CredentialType.ID_TOKEN:\n                return CacheType.ID_TOKEN;\n            case CredentialType.ACCESS_TOKEN:\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                return CacheType.ACCESS_TOKEN;\n            case CredentialType.REFRESH_TOKEN:\n                return CacheType.REFRESH_TOKEN;\n            default: {\n                throw ClientAuthError.createUnexpectedCredentialTypeError();\n            }\n        }\n    }\n\n    /**\n     * helper function to return `CredentialType`\n     * @param key\n     */\n    static getCredentialType(key: string): string {\n        // First keyword search will match all \"AccessToken\" and \"AccessToken_With_AuthScheme\" credentials\n        if (key.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) !== -1) {\n            // Perform second search to differentiate between \"AccessToken\" and \"AccessToken_With_AuthScheme\" credential types\n            if (key.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) !== -1) {\n                return CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n            }\n            return CredentialType.ACCESS_TOKEN;\n        } else if (key.indexOf(CredentialType.ID_TOKEN.toLowerCase()) !== -1) {\n            return CredentialType.ID_TOKEN;\n        } else if (key.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) !== -1) {\n            return CredentialType.REFRESH_TOKEN;\n        }\n\n        return Constants.NOT_DEFINED;\n    }\n\n    /**\n     * generates credential key\n     * <home_account_id*>-\\<environment>-<credential_type>-<client_id>-<realm\\*>-<target\\*>-<scheme\\*>\n     */\n    static generateCredentialCacheKey(\n        homeAccountId: string,\n        environment: string,\n        credentialType: CredentialType,\n        clientId: string,\n        realm?: string,\n        target?: string,\n        familyId?: string,\n        tokenType?: AuthenticationScheme,\n        requestedClaimsHash?: string\n    ): string {\n        const credentialKey = [\n            this.generateAccountIdForCacheKey(homeAccountId, environment),\n            this.generateCredentialIdForCacheKey(credentialType, clientId, realm, familyId),\n            this.generateTargetForCacheKey(target),\n            this.generateClaimsHashForCacheKey(requestedClaimsHash),\n            this.generateSchemeForCacheKey(tokenType)\n        ];\n\n        return credentialKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * generates Account Id for keys\n     * @param homeAccountId\n     * @param environment\n     */\n    private static generateAccountIdForCacheKey(\n        homeAccountId: string,\n        environment: string\n    ): string {\n        const accountId: Array<string> = [homeAccountId, environment];\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generates Credential Id for keys\n     * @param credentialType\n     * @param realm\n     * @param clientId\n     * @param familyId\n     */\n    private static generateCredentialIdForCacheKey(\n        credentialType: CredentialType,\n        clientId: string,\n        realm?: string,\n        familyId?: string\n    ): string {\n        const clientOrFamilyId =\n            credentialType === CredentialType.REFRESH_TOKEN\n                ? familyId || clientId\n                : clientId;\n        const credentialId: Array<string> = [\n            credentialType,\n            clientOrFamilyId,\n            realm || Constants.EMPTY_STRING,\n        ];\n\n        return credentialId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generate target key component as per schema: <target>\n     */\n    private static generateTargetForCacheKey(scopes?: string): string {\n        return (scopes || Constants.EMPTY_STRING).toLowerCase();\n    }\n\n    /**\n     * Generate requested claims key component as per schema: <requestedClaims>\n     */\n    private static generateClaimsHashForCacheKey(requestedClaimsHash?: string): string {\n        return(requestedClaimsHash || Constants.EMPTY_STRING).toLowerCase();\n    }\n\n    /**\n     * Generate scheme key componenet as per schema: <scheme>\n     */\n    private static generateSchemeForCacheKey(tokenType?: string): string {\n        /*\n         * PoP Tokens and SSH certs include scheme in cache key\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        return (tokenType && tokenType.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? tokenType.toLowerCase() : Constants.EMPTY_STRING;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}