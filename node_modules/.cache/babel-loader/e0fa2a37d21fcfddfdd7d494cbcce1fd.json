{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { GrantType, Constants } from '../utils/Constants.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * OAuth2.0 Device code client\r\n */\n\nvar DeviceCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(DeviceCodeClient, _super);\n\n  function DeviceCodeClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Gets device code from device code endpoint, calls back to with device code response, and\r\n   * polls token endpoint to exchange device code for tokens\r\n   * @param request\r\n   */\n\n\n  DeviceCodeClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var deviceCodeResponse, reqTimestamp, response, responseHandler;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getDeviceCode(request)];\n\n          case 1:\n            deviceCodeResponse = _a.sent();\n            request.deviceCodeCallback(deviceCodeResponse);\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4\n            /*yield*/\n            , this.acquireTokenWithDeviceCode(request, deviceCodeResponse)];\n\n          case 2:\n            response = _a.sent();\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response);\n            return [4\n            /*yield*/\n            , responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates device code request and executes http GET\r\n   * @param request\r\n   */\n\n\n  DeviceCodeClient.prototype.getDeviceCode = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString, headers, thumbprint;\n      return __generator(this, function (_a) {\n        queryString = this.createQueryString(request);\n        headers = this.createTokenRequestHeaders();\n        thumbprint = {\n          clientId: this.config.authOptions.clientId,\n          authority: request.authority,\n          scopes: request.scopes,\n          claims: request.claims,\n          authenticationScheme: request.authenticationScheme,\n          resourceRequestMethod: request.resourceRequestMethod,\n          resourceRequestUri: request.resourceRequestUri,\n          shrClaims: request.shrClaims,\n          sshKid: request.sshKid\n        };\n        return [2\n        /*return*/\n        , this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint)];\n      });\n    });\n  };\n  /**\r\n   * Executes POST request to device code endpoint\r\n   * @param deviceCodeEndpoint\r\n   * @param queryString\r\n   * @param headers\r\n   */\n\n\n  DeviceCodeClient.prototype.executePostRequestToDeviceCodeEndpoint = function (deviceCodeEndpoint, queryString, headers, thumbprint) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, userCode, deviceCode, verificationUri, expiresIn, interval, message;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.networkManager.sendPostRequest(thumbprint, deviceCodeEndpoint, {\n              body: queryString,\n              headers: headers,\n              proxyUrl: this.config.systemOptions.proxyUrl\n            })];\n\n          case 1:\n            _a = _b.sent().body, userCode = _a.user_code, deviceCode = _a.device_code, verificationUri = _a.verification_uri, expiresIn = _a.expires_in, interval = _a.interval, message = _a.message;\n            return [2\n            /*return*/\n            , {\n              userCode: userCode,\n              deviceCode: deviceCode,\n              verificationUri: verificationUri,\n              expiresIn: expiresIn,\n              interval: interval,\n              message: message\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * Create device code endpoint query parameters and returns string\r\n   */\n\n\n  DeviceCodeClient.prototype.createQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addScopes(request.scopes);\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n    if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Breaks the polling with specific conditions.\r\n   * @param request CommonDeviceCodeRequest\r\n   * @param deviceCodeResponse DeviceCodeResponse\r\n   */\n\n\n  DeviceCodeClient.prototype.continuePolling = function (deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {\n    if (userSpecifiedCancelFlag) {\n      this.logger.error(\"Token request cancelled by setting DeviceCodeRequest.cancel = true\");\n      throw ClientAuthError.createDeviceCodeCancelledError();\n    } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {\n      this.logger.error(\"User defined timeout for device code polling reached. The timeout was set for \" + userSpecifiedTimeout);\n      throw ClientAuthError.createUserTimeoutReachedError();\n    } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {\n      if (userSpecifiedTimeout) {\n        this.logger.verbose(\"User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for \" + userSpecifiedTimeout);\n      }\n\n      this.logger.error(\"Device code expired. Expiration time of device code was \" + deviceCodeExpirationTime);\n      throw ClientAuthError.createDeviceCodeExpiredError();\n    }\n\n    return true;\n  };\n  /**\r\n   * Creates token request with device code response and polls token endpoint at interval set by the device code\r\n   * response\r\n   * @param request\r\n   * @param deviceCodeResponse\r\n   */\n\n\n  DeviceCodeClient.prototype.acquireTokenWithDeviceCode = function (request, deviceCodeResponse) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestBody, headers, userSpecifiedTimeout, deviceCodeExpirationTime, pollingIntervalMilli, thumbprint, response;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            requestBody = this.createTokenRequestBody(request, deviceCodeResponse);\n            headers = this.createTokenRequestHeaders();\n            userSpecifiedTimeout = request.timeout ? TimeUtils.nowSeconds() + request.timeout : undefined;\n            deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;\n            pollingIntervalMilli = deviceCodeResponse.interval * 1000;\n            _a.label = 1;\n\n          case 1:\n            if (!this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) return [3\n            /*break*/\n            , 8];\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: request.authority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [4\n            /*yield*/\n            , this.executePostToTokenEndpoint(this.authority.tokenEndpoint, requestBody, headers, thumbprint)];\n\n          case 2:\n            response = _a.sent();\n            if (!(response.body && response.body.error)) return [3\n            /*break*/\n            , 6];\n            if (!(response.body.error === Constants.AUTHORIZATION_PENDING)) return [3\n            /*break*/\n            , 4];\n            this.logger.info(\"Authorization pending. Continue polling.\");\n            return [4\n            /*yield*/\n            , TimeUtils.delay(pollingIntervalMilli)];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            // for any other error, throw\n            this.logger.info(\"Unexpected error in polling from the server\");\n            throw ServerError.createPostRequestFailed(response.body.error);\n\n          case 5:\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            this.logger.verbose(\"Authorization completed successfully. Polling stopped.\");\n            return [2\n            /*return*/\n            , response.body];\n\n          case 7:\n            return [3\n            /*break*/\n            , 1];\n\n          case 8:\n            /*\r\n             * The above code should've thrown by this point, but to satisfy TypeScript,\r\n             * and in the rare case the conditionals in continuePolling() may not catch everything...\r\n             */\n            this.logger.error(\"Polling stopped for unknown reasons.\");\n            throw ClientAuthError.createDeviceCodeUnknownError();\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates query parameters and converts to string.\r\n   * @param request\r\n   * @param deviceCodeResponse\r\n   */\n\n\n  DeviceCodeClient.prototype.createTokenRequestBody = function (request, deviceCodeResponse) {\n    var requestParameters = new RequestParameterBuilder();\n    requestParameters.addScopes(request.scopes);\n    requestParameters.addClientId(this.config.authOptions.clientId);\n    requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);\n    requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);\n    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    requestParameters.addCorrelationId(correlationId);\n    requestParameters.addClientInfo();\n    requestParameters.addLibraryInfo(this.config.libraryInfo);\n    requestParameters.addApplicationTelemetry(this.config.telemetry.application);\n    requestParameters.addThrottling();\n\n    if (this.serverTelemetryManager) {\n      requestParameters.addServerTelemetry(this.serverTelemetryManager);\n    }\n\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      requestParameters.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n\n    return requestParameters.createQueryString();\n  };\n\n  return DeviceCodeClient;\n}(BaseClient);\n\nexport { DeviceCodeClient };","map":{"version":3,"mappings":"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","names":["__extends","configuration","DeviceCodeClient","acquireToken","request","getDeviceCode","deviceCodeResponse","_a","deviceCodeCallback","reqTimestamp","TimeUtils","nowSeconds","acquireTokenWithDeviceCode","response","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","logger","serializableCache","persistencePlugin","validateTokenResponse","handleServerTokenResponse","authority","queryString","createQueryString","headers","createTokenRequestHeaders","thumbprint","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostRequestToDeviceCodeEndpoint","deviceCodeEndpoint","networkManager","sendPostRequest","body","proxyUrl","systemOptions","userCode","deviceCode","verificationUri","expiresIn","interval","message","parameterBuilder","RequestParameterBuilder","addScopes","addClientId","StringUtils","isEmpty","clientCapabilities","length","addClaims","deviceCodeExpirationTime","userSpecifiedTimeout","userSpecifiedCancelFlag","error","ClientAuthError","createDeviceCodeCancelledError","createUserTimeoutReachedError","verbose","createDeviceCodeExpiredError","requestBody","createTokenRequestBody","timeout","undefined","pollingIntervalMilli","continuePolling","cancel","executePostToTokenEndpoint","tokenEndpoint","Constants","AUTHORIZATION_PENDING","info","delay","ServerError","createPostRequestFailed","createDeviceCodeUnknownError","requestParameters","addGrantType","GrantType","DEVICE_CODE_GRANT","addDeviceCode","correlationId","cryptoInterface","createNewGuid","addCorrelationId","addClientInfo","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","addServerTelemetry","isEmptyObj","BaseClient"],"sources":["../../src/client/DeviceCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DeviceCodeResponse, ServerDeviceCodeResponse } from \"../response/DeviceCodeResponse\";\nimport { BaseClient } from \"./BaseClient\";\nimport { CommonDeviceCodeRequest } from \"../request/CommonDeviceCodeRequest\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\nimport { Constants, GrantType } from \"../utils/Constants\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\nimport { ServerError } from \"../error/ServerError\";\n\n/**\n * OAuth2.0 Device code client\n */\nexport class DeviceCodeClient extends BaseClient {\n\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * Gets device code from device code endpoint, calls back to with device code response, and\n     * polls token endpoint to exchange device code for tokens\n     * @param request\n     */\n    public async acquireToken(request: CommonDeviceCodeRequest): Promise<AuthenticationResult | null> {\n        const deviceCodeResponse: DeviceCodeResponse = await this.getDeviceCode(request);\n        request.deviceCodeCallback(deviceCodeResponse);\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response: ServerAuthorizationTokenResponse = await this.acquireTokenWithDeviceCode(\n            request,\n            deviceCodeResponse);\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response);\n        return await responseHandler.handleServerTokenResponse(\n            response,\n            this.authority,\n            reqTimestamp,\n            request\n        );\n    }\n\n    /**\n     * Creates device code request and executes http GET\n     * @param request\n     */\n    private async getDeviceCode(request: CommonDeviceCodeRequest): Promise<DeviceCodeResponse> {\n        const queryString = this.createQueryString(request);\n        const headers = this.createTokenRequestHeaders();\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: request.authority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid\n        };\n\n        return this.executePostRequestToDeviceCodeEndpoint(this.authority.deviceCodeEndpoint, queryString, headers, thumbprint);\n    }\n\n    /**\n     * Executes POST request to device code endpoint\n     * @param deviceCodeEndpoint\n     * @param queryString\n     * @param headers\n     */\n    private async executePostRequestToDeviceCodeEndpoint(\n        deviceCodeEndpoint: string,\n        queryString: string,\n        headers: Record<string, string>,\n        thumbprint: RequestThumbprint): Promise<DeviceCodeResponse> {\n\n        const {\n            body: {\n                user_code: userCode,\n                device_code: deviceCode,\n                verification_uri: verificationUri,\n                expires_in: expiresIn,\n                interval,\n                message\n            }\n        } = await this.networkManager.sendPostRequest<ServerDeviceCodeResponse>(\n            thumbprint,\n            deviceCodeEndpoint,\n            {\n                body: queryString,\n                headers: headers,\n                proxyUrl: this.config.systemOptions.proxyUrl\n            });\n\n        return {\n            userCode,\n            deviceCode,\n            verificationUri,\n            expiresIn,\n            interval,\n            message\n        };\n    }\n\n    /**\n     * Create device code endpoint query parameters and returns string\n     */\n    private createQueryString(request: CommonDeviceCodeRequest): string {\n\n        const parameterBuilder: RequestParameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addScopes(request.scopes);\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * Breaks the polling with specific conditions.\n     * @param request CommonDeviceCodeRequest\n     * @param deviceCodeResponse DeviceCodeResponse\n     */\n    private continuePolling(\n        deviceCodeExpirationTime: number,\n        userSpecifiedTimeout?: number,\n        userSpecifiedCancelFlag?: boolean,\n    ): boolean {\n        if (userSpecifiedCancelFlag) {\n            this.logger.error(\"Token request cancelled by setting DeviceCodeRequest.cancel = true\");\n            throw ClientAuthError.createDeviceCodeCancelledError();\n        } else if (userSpecifiedTimeout && userSpecifiedTimeout < deviceCodeExpirationTime && TimeUtils.nowSeconds() > userSpecifiedTimeout) {\n            this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);\n            throw ClientAuthError.createUserTimeoutReachedError();\n        } else if (TimeUtils.nowSeconds() > deviceCodeExpirationTime) {\n            if (userSpecifiedTimeout) {\n                this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);\n            }\n            this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);\n            throw ClientAuthError.createDeviceCodeExpiredError();\n        }\n        return true;\n    }\n\n    /**\n     * Creates token request with device code response and polls token endpoint at interval set by the device code\n     * response\n     * @param request\n     * @param deviceCodeResponse\n     */\n    private async acquireTokenWithDeviceCode(\n        request: CommonDeviceCodeRequest,\n        deviceCodeResponse: DeviceCodeResponse): Promise<ServerAuthorizationTokenResponse> {\n\n        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);\n        const headers: Record<string, string> = this.createTokenRequestHeaders();\n\n        const userSpecifiedTimeout = request.timeout ? TimeUtils.nowSeconds() + request.timeout : undefined;\n        const deviceCodeExpirationTime = TimeUtils.nowSeconds() + deviceCodeResponse.expiresIn;\n        const pollingIntervalMilli = deviceCodeResponse.interval * 1000;\n\n        /*\n         * Poll token endpoint while (device code is not expired AND operation has not been cancelled by\n         * setting CancellationToken.cancel = true). POST request is sent at interval set by pollingIntervalMilli\n         */\n        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) {\n            const thumbprint: RequestThumbprint = {\n                clientId: this.config.authOptions.clientId,\n                authority: request.authority,\n                scopes: request.scopes,\n                claims: request.claims,\n                authenticationScheme: request.authenticationScheme,\n                resourceRequestMethod: request.resourceRequestMethod,\n                resourceRequestUri: request.resourceRequestUri,\n                shrClaims: request.shrClaims,\n                sshKid: request.sshKid\n            };\n\n            const response = await this.executePostToTokenEndpoint(\n                this.authority.tokenEndpoint,\n                requestBody,\n                headers,\n                thumbprint);\n\n            if (response.body && response.body.error) {\n                // user authorization is pending. Sleep for polling interval and try again\n                if(response.body.error === Constants.AUTHORIZATION_PENDING) {\n                    this.logger.info(\"Authorization pending. Continue polling.\");\n                    await TimeUtils.delay(pollingIntervalMilli);\n                } else {\n                    // for any other error, throw\n                    this.logger.info(\"Unexpected error in polling from the server\");\n                    throw ServerError.createPostRequestFailed(response.body.error);\n                }\n            } else {\n                this.logger.verbose(\"Authorization completed successfully. Polling stopped.\");\n                return response.body;\n            }\n        }\n\n        /*\n         * The above code should've thrown by this point, but to satisfy TypeScript,\n         * and in the rare case the conditionals in continuePolling() may not catch everything...\n         */\n        this.logger.error(\"Polling stopped for unknown reasons.\");\n        throw ClientAuthError.createDeviceCodeUnknownError();\n    }\n\n    /**\n     * Creates query parameters and converts to string.\n     * @param request\n     * @param deviceCodeResponse\n     */\n    private createTokenRequestBody(request: CommonDeviceCodeRequest, deviceCodeResponse: DeviceCodeResponse): string {\n\n        const requestParameters: RequestParameterBuilder = new RequestParameterBuilder();\n\n        requestParameters.addScopes(request.scopes);\n        requestParameters.addClientId(this.config.authOptions.clientId);\n        requestParameters.addGrantType(GrantType.DEVICE_CODE_GRANT);\n        requestParameters.addDeviceCode(deviceCodeResponse.deviceCode);\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n        requestParameters.addCorrelationId(correlationId);\n        requestParameters.addClientInfo();\n        requestParameters.addLibraryInfo(this.config.libraryInfo);\n        requestParameters.addApplicationTelemetry(this.config.telemetry.application);\n        requestParameters.addThrottling();\n        \n        if (this.serverTelemetryManager) {\n            requestParameters.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            requestParameters.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n        return requestParameters.createQueryString();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}