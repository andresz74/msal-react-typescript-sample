{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { RefreshTokenClient } from './RefreshTokenClient.js';\nimport { ClientAuthError, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { CacheOutcome } from '../utils/Constants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar SilentFlowClient =\n/** @class */\nfunction (_super) {\n  __extends(SilentFlowClient, _super);\n\n  function SilentFlowClient(configuration, performanceClient) {\n    return _super.call(this, configuration, performanceClient) || this;\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, refreshTokenClient;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.acquireCachedToken(request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n              refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n              return [2\n              /*return*/\n              , refreshTokenClient.acquireTokenByRefreshToken(request)];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireCachedToken = function (request) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var environment, cacheRecord;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            // Cannot renew token if no request object is given.\n            if (!request) {\n              throw ClientConfigurationError.createEmptyTokenRequestError();\n            }\n\n            if (request.forceRefresh) {\n              // Must refresh due to present force_refresh flag.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n\n\n            if (!request.account) {\n              throw ClientAuthError.createNoAccountInSilentRequestError();\n            }\n\n            environment = request.authority || this.authority.getPreferredCache();\n            cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);\n\n            if (!cacheRecord.accessToken) {\n              // Must refresh due to non-existent access_token.\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Must refresh due to expired access_token.\n              (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n              // Must refresh due to the refresh_in value.\n              (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n\n            return [4\n            /*yield*/\n            , this.generateResultFromCacheRecord(cacheRecord, request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _e.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n\n\n  SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (cacheRecord.idToken) {\n              idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n            }\n\n            return [4\n            /*yield*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return SilentFlowClient;\n}(BaseClient);\n\nexport { SilentFlowClient };","map":{"version":3,"mappings":"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","names":["__extends","SilentFlowClient","configuration","performanceClient","_super","acquireToken","request","acquireCachedToken","_a","e_1","ClientAuthError","errorCode","ClientAuthErrorMessage","tokenRefreshRequired","code","refreshTokenClient","RefreshTokenClient","config","acquireTokenByRefreshToken","ClientConfigurationError","createEmptyTokenRequestError","forceRefresh","serverTelemetryManager","setCacheOutcome","CacheOutcome","FORCE_REFRESH","logger","info","createRefreshRequiredError","account","createNoAccountInSilentRequestError","environment","authority","getPreferredCache","cacheRecord","cacheManager","readCacheRecord","authOptions","clientId","accessToken","_b","NO_CACHED_ACCESS_TOKEN","TimeUtils","wasClockTurnedBack","cachedAt","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","_c","CACHED_ACCESS_TOKEN_EXPIRED","refreshOn","_d","REFRESH_CACHED_ACCESS_TOKEN","incrementCacheHits","generateResultFromCacheRecord","_e","idToken","idTokenObj","AuthToken","secret","cryptoInterface","generateAuthenticationResult","cryptoUtils","BaseClient"],"sources":["../../src/client/SilentFlowClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\nimport { CacheOutcome } from \"../utils/Constants\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\n\nexport class SilentFlowClient extends BaseClient {\n    \n    constructor(configuration: ClientConfiguration, performanceClient?: IPerformanceClient) {\n        super(configuration,performanceClient);\n    }\n\n    /**\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\n     * the given token and returns the renewed token\n     * @param request\n     */\n    async acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        try {\n            return await this.acquireCachedToken(request);\n        } catch (e) {\n            if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n                const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Retrieves token from cache or throws an error if it must be refreshed.\n     * @param request\n     */\n    async acquireCachedToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n            throw ClientConfigurationError.createEmptyTokenRequestError();\n        }\n\n        if (request.forceRefresh) {\n            // Must refresh due to present force_refresh flag.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw ClientAuthError.createNoAccountInSilentRequestError();\n        }\n\n        const environment = request.authority || this.authority.getPreferredCache();\n\n        const cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);\n\n        if (!cacheRecord.accessToken) {\n            // Must refresh due to non-existent access_token.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (\n            TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)\n        ) {\n            // Must refresh due to expired access_token.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n            this.logger.info(`SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n            // Must refresh due to the refresh_in value.\n            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n            this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        if (this.config.serverTelemetryManager) {\n            this.config.serverTelemetryManager.incrementCacheHits();\n        }\n\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\n    }\n\n    /**\n     * Helper function to build response object from the CacheRecord\n     * @param cacheRecord\n     */\n    private async generateResultFromCacheRecord(cacheRecord: CacheRecord, request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\n        let idTokenObj: AuthToken | undefined;\n        if (cacheRecord.idToken) {\n            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n        }\n        return await ResponseHandler.generateAuthenticationResult(\n            this.cryptoUtils,\n            this.authority,\n            cacheRecord,\n            true,\n            request,\n            idTokenObj\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}