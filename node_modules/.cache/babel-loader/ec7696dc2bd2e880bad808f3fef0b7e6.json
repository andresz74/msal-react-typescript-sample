{"ast":null,"code":"/*! @azure/msal-common v7.4.0 2022-09-06 */\n'use strict';\n\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * @hidden\r\n */\n\nvar StringUtils =\n/** @class */\nfunction () {\n  function StringUtils() {}\n  /**\r\n   * decode a JWT\r\n   *\r\n   * @param authToken\r\n   */\n\n\n  StringUtils.decodeAuthToken = function (authToken) {\n    if (StringUtils.isEmpty(authToken)) {\n      throw ClientAuthError.createTokenNullOrEmptyError(authToken);\n    }\n\n    var tokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n    var matches = tokenPartsRegex.exec(authToken);\n\n    if (!matches || matches.length < 4) {\n      throw ClientAuthError.createTokenParsingError(\"Given token is malformed: \" + JSON.stringify(authToken));\n    }\n\n    var crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n    return crackedToken;\n  };\n  /**\r\n   * Check if a string is empty.\r\n   *\r\n   * @param str\r\n   */\n\n\n  StringUtils.isEmpty = function (str) {\n    return typeof str === \"undefined\" || !str || 0 === str.length;\n  };\n  /**\r\n   * Check if stringified object is empty\r\n   * @param strObj\r\n   */\n\n\n  StringUtils.isEmptyObj = function (strObj) {\n    if (strObj && !StringUtils.isEmpty(strObj)) {\n      try {\n        var obj = JSON.parse(strObj);\n        return Object.keys(obj).length === 0;\n      } catch (e) {}\n    }\n\n    return true;\n  };\n\n  StringUtils.startsWith = function (str, search) {\n    return str.indexOf(search) === 0;\n  };\n\n  StringUtils.endsWith = function (str, search) {\n    return str.length >= search.length && str.lastIndexOf(search) === str.length - search.length;\n  };\n  /**\r\n   * Parses string into an object.\r\n   *\r\n   * @param query\r\n   */\n\n\n  StringUtils.queryStringToObject = function (query) {\n    var obj = {};\n    var params = query.split(\"&\");\n\n    var decode = function (s) {\n      return decodeURIComponent(s.replace(/\\+/g, \" \"));\n    };\n\n    params.forEach(function (pair) {\n      if (pair.trim()) {\n        var _a = pair.split(/=(.+)/g, 2),\n            key = _a[0],\n            value = _a[1]; // Split on the first occurence of the '=' character\n\n\n        if (key && value) {\n          obj[decode(key)] = decode(value);\n        }\n      }\n    });\n    return obj;\n  };\n  /**\r\n   * Trims entries in an array.\r\n   *\r\n   * @param arr\r\n   */\n\n\n  StringUtils.trimArrayEntries = function (arr) {\n    return arr.map(function (entry) {\n      return entry.trim();\n    });\n  };\n  /**\r\n   * Removes empty strings from array\r\n   * @param arr\r\n   */\n\n\n  StringUtils.removeEmptyStringsFromArray = function (arr) {\n    return arr.filter(function (entry) {\n      return !StringUtils.isEmpty(entry);\n    });\n  };\n  /**\r\n   * Attempts to parse a string into JSON\r\n   * @param str\r\n   */\n\n\n  StringUtils.jsonParseHelper = function (str) {\n    try {\n      return JSON.parse(str);\n    } catch (e) {\n      return null;\n    }\n  };\n  /**\r\n   * Tests if a given string matches a given pattern, with support for wildcards and queries.\r\n   * @param pattern Wildcard pattern to string match. Supports \"*\" for wildcards and \"?\" for queries\r\n   * @param input String to match against\r\n   */\n\n\n  StringUtils.matchPattern = function (pattern, input) {\n    /**\r\n     * Wildcard support: https://stackoverflow.com/a/3117248/4888559\r\n     * Queries: replaces \"?\" in string with escaped \"\\?\" for regex test\r\n     */\n    var regex = new RegExp(pattern.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\*/g, \"[^ ]*\").replace(/\\?/g, \"\\\\\\?\")); // eslint-disable-line security/detect-non-literal-regexp\n\n    return regex.test(input);\n  };\n\n  return StringUtils;\n}();\n\nexport { StringUtils };","map":{"version":3,"mappings":"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","names":["StringUtils","authToken","isEmpty","ClientAuthError","createTokenNullOrEmptyError","tokenPartsRegex","matches","exec","length","createTokenParsingError","JSON","stringify","crackedToken","header","JWSPayload","JWSSig","str","strObj","obj","parse","Object","keys","e","search","indexOf","lastIndexOf","query","params","split","decode","s","replace","forEach","pair","trim","key","value","_a","arr","map","filter","entry","pattern","input","regex","RegExp","test"],"sources":["../../src/utils/StringUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DecodedAuthToken } from \"../account/DecodedAuthToken\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\n\n/**\n * @hidden\n */\nexport class StringUtils {\n\n    /**\n     * decode a JWT\n     *\n     * @param authToken\n     */\n    static decodeAuthToken(authToken: string): DecodedAuthToken {\n        if (StringUtils.isEmpty(authToken)) {\n            throw ClientAuthError.createTokenNullOrEmptyError(authToken);\n        }\n        const tokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n        const matches = tokenPartsRegex.exec(authToken);\n        if (!matches || matches.length < 4) {\n            throw ClientAuthError.createTokenParsingError(`Given token is malformed: ${JSON.stringify(authToken)}`);\n        }\n        const crackedToken: DecodedAuthToken = {\n            header: matches[1],\n            JWSPayload: matches[2],\n            JWSSig: matches[3]\n        };\n        return crackedToken;\n    }\n\n    /**\n     * Check if a string is empty.\n     *\n     * @param str\n     */\n    static isEmpty(str?: string): boolean {\n        return (typeof str === \"undefined\" || !str || 0 === str.length);\n    }\n\n    /**\n     * Check if stringified object is empty\n     * @param strObj \n     */\n    static isEmptyObj(strObj?: string): boolean {\n        if (strObj && !StringUtils.isEmpty(strObj)) {\n            try {\n                const obj = JSON.parse(strObj);\n                return Object.keys(obj).length === 0;\n            } catch (e) {}\n        }\n        return true;\n    }\n\n    static startsWith(str: string, search: string): boolean {\n        return str.indexOf(search) === 0;\n    }\n\n    static endsWith(str: string, search: string): boolean {\n        return (str.length >= search.length) && (str.lastIndexOf(search) === (str.length - search.length));\n    }\n\n    /**\n     * Parses string into an object.\n     *\n     * @param query\n     */\n    static queryStringToObject<T>(query: string): T {\n        const obj: {} = {};\n        const params = query.split(\"&\");\n        const decode = (s: string) => decodeURIComponent(s.replace(/\\+/g, \" \"));\n        params.forEach((pair) => {\n            if (pair.trim()) {\n                const [key, value] = pair.split(/=(.+)/g, 2); // Split on the first occurence of the '=' character\n                if (key && value) {\n                    obj[decode(key)] = decode(value);\n                }\n            }\n        });\n        return obj as T;\n    }\n\n    /**\n     * Trims entries in an array.\n     *\n     * @param arr\n     */\n    static trimArrayEntries(arr: Array<string>): Array<string> {\n        return arr.map(entry => entry.trim());\n    }\n\n    /**\n     * Removes empty strings from array\n     * @param arr\n     */\n    static removeEmptyStringsFromArray(arr: Array<string>): Array<string> {\n        return arr.filter(entry => {\n            return !StringUtils.isEmpty(entry);\n        });\n    }\n\n    /**\n     * Attempts to parse a string into JSON\n     * @param str\n     */\n    static jsonParseHelper<T>(str: string): T | null {\n        try {\n            return JSON.parse(str) as T;\n        } catch (e) {\n            return null;\n        }\n    }\n\n    /**\n     * Tests if a given string matches a given pattern, with support for wildcards and queries.\n     * @param pattern Wildcard pattern to string match. Supports \"*\" for wildcards and \"?\" for queries\n     * @param input String to match against\n     */\n    static matchPattern(pattern: string, input: string): boolean {\n        /**\n         * Wildcard support: https://stackoverflow.com/a/3117248/4888559\n         * Queries: replaces \"?\" in string with escaped \"\\?\" for regex test\n         */\n        const regex: RegExp = new RegExp(pattern.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\*/g, \"[^ ]*\").replace(/\\?/g, \"\\\\\\?\")); // eslint-disable-line security/detect-non-literal-regexp\n\n        return regex.test(input);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}